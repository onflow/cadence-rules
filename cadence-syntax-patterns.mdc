---
description: Provides a comprehensive guide to syntax patterns, best practices, and common pitfalls in the Cadence language. Covers resource type syntax (@,&), interface restrictions ({}), transaction authorization patterns, contract member access, type conversion, access modifiers, view function purity, and debugging approaches. Includes language-specific patterns for optional binding, variable initialization, string manipulation, looping constructs, and idempotent transaction design.
alwaysApply: false
---
# Cadence Syntax Patterns & Best Practices

## Resource Type Syntax
- **Resource Declaration**: Use `@` symbol for resource types
  ```cadence
  var ownedNFTs: @{UInt64: {NonFungibleToken.NFT}}
  ```

- **Resource Parameters**: Use `@` for resource parameters
  ```cadence
  access(all) fun deposit(token: @{NonFungibleToken.NFT})
  ```

- **Resource References**: Use `&` for references
  ```cadence
  access(all) fun borrowNFT(_ id: UInt64): &{NonFungibleToken.NFT}?
  ```

## Interface Restrictions
Use curly braces `{}` for interface restrictions instead of direct interface types:
- **Correct**: `@{NonFungibleToken.NFT}` 
- **Incorrect**: `@NonFungibleToken.NFT`

## Reference Borrowing Patterns
- **Safe Borrowing**: 
  ```cadence
  let ref = &self.ownedNFTs[id]
  if ref != nil {
      return ref as! &MyNFT
  }
  ```

- **Avoid Complex Auth Casting**: Simplify authorization patterns
  ```cadence
  // Prefer simple casting over complex auth expressions
  let ref = &self.ownedNFTs[id] as! &MySpecificNFT
  ```

## Transaction Authorization Patterns
### Authorization Granularity
- **Principle of Least Privilege**: Grant only the necessary capabilities. Avoid overly broad authorizations if not required.
- **Storage Operations**: 
    - For full control: `signer: auth(Storage) &Account`
    - For granular control: `signer: auth(Mutate, Insert, Remove) &Account` (or a subset)
    - For specific standard operations (NFT, FT): Consider the five-capability model: `auth(BorrowValue, IssueStorageCapabilityController, SaveValue, UnpublishCapability, PublishCapability) &Account` when interacting with standard capabilities directly.
- **Read-Only Access**: If a transaction only reads public data or borrows public capabilities, it might not need any `auth` on the `signer` or might use `auth(Capabilities)` for linking public capabilities.

### Complete Authorization Template (Example for standard setup)
When setting up standard resources like an NFT Collection:
```cadence
transaction {
    prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, UnpublishCapability, PublishCapability) &Account) {
        // Example: Setup NFT Collection
        if signer.storage.borrow<&NonFungibleToken.Collection>(from: /storage/MyNFTCollection) == nil {
            let collection <- NonFungibleToken.createEmptyCollection()
            signer.storage.save(<-collection, to: /storage/MyNFTCollection)
            signer.capabilities.unpublish(/public/MyNFTCollection)
            signer.capabilities.publish(
                signer.capabilities.storage.issue<&NonFungibleToken.Collection>(/storage/MyNFTCollection),
                at: /public/MyNFTCollection
            )
        }
    }
}
```

### Authorization Error Prevention
- **Verify Signer Capabilities**: Ensure the signing account *actually possesses* the capabilities being authorized (e.g., has storage space, controllers for paths if `IssueStorageCapabilityController` is used for specific paths).
- **Match to Operation**: The most common error is a mismatch. If you `save`, you need `SaveValue` or broader `Storage`/`Mutate`. If you `publish`, you need `PublishCapability`.
- **Check `flow.json`**: Ensure the signer account in `flow.json` used for sending the transaction is the intended one with the correct keys.

## Contract Member Access Patterns
### Accessing Contract Constants and Functions
```cadence
// Correct - accessing public contract members (assuming they are defined as `access(all)` in the deployed contract)
let storagePath = MyContractName.CollectionStoragePath
let publicPath = MyContractName.CollectionPublicPath
let newNFT <- MyContractName.mintNFT(arg1, arg2)

// Error-prone - assuming members exist without verification
// ALWAYS verify the *deployed* contract has these as public members with the correct signature.
// Discrepancies between local .cdc file and deployed code are common sources of "unknown member" errors.
```

### Function Call Patterns
```cadence
// Verify function signatures from the *deployed* contract before calling.
// If createEmptyCollection() expects arguments on the deployed contract, provide them.
// let collection <- ContractName.createEmptyCollection(nftType: Type<@ContractName.NFT>()) // Example if it takes an argument

// For zero-argument functions (as defined in the deployed contract):
let collection <- ContractName.createEmptyCollection()
```

## Transaction Arguments and Hardcoding
- **Parameterize Transactions**: Prefer passing values as arguments to transactions rather than hardcoding them directly in the Cadence code, especially for values that might change or vary.
  ```cadence
  // Less flexible (hardcoded lifespanDays)
  transaction {
    // ...
    let lifespanDays = 10.0
    // ...
  }
  
  // More flexible (lifespanDays as an argument)
  transaction(lifespanDays: UFix64) {
    // ...
    // use lifespanDays argument
    // ...
  }
  ```
- **Configuration Constants**: For true constants related to contract logic that don't change per transaction, define them in the contract itself.

## Common Type Errors to Avoid
- **Dictionary Types**: Use `@{UInt64: {NonFungibleToken.NFT}}` not `@{UInt64: NonFungibleToken.NFT}`
- **Function Returns**: Use `@{NonFungibleToken.Collection}` not `@NonFungibleToken.Collection`
- **Type Casting**: Use interface restrictions in Type<> expressions: `Type<&MyContract.Collection>()`

## Access Modifiers & Entitlements
- **Withdraw Functions**: Use proper entitlements
  ```cadence
  access(NonFungibleToken.Withdraw) fun withdraw(withdrawID: UInt64): @{NonFungibleToken.NFT}
  ```

- **View Functions**: Mark read-only functions as `view`
  ```cadence
  access(all) view fun getIDs(): [UInt64]
  ```

## Contract Structure
- **Single Contract per File**: Each .cdc file should contain exactly one contract/interface
- **Nested Definitions**: Place supporting structs, resources, and interfaces inside the contract block
- **Import Organization**: Place all imports at the top of the file

## Error Prevention Patterns
- **Type Consistency**: Ensure consistent use of resource symbols and interface restrictions
- **Reference Safety**: Always check for nil before using optional references
- **Entitlement Usage**: Use appropriate entitlements for privileged functions
- **Interface Conformance**: Ensure all required interface methods are implemented
- **Authorization Completeness**: Include all necessary and *correctly scoped* capabilities in transaction `prepare()`.
- **Contract Member Verification**: Verify contract deployment and public member availability *on the target network*.

## Debugging Approach
When encountering Cadence compilation errors:
1. Check for missing `@` or `&` symbols in type declarations
2. Verify interface restrictions use `{}` syntax
3. Ensure single contract per file structure
4. Reference official Flow documentation and standard contracts
5. Compare against working examples from Flow's core contracts repository
6. **For authorization errors**: Ensure the `signer` has the correct `auth` capabilities for the operations performed in the transaction.
7. **For "unknown member" errors**: Verify the member exists and is `access(all)` in the *deployed contract code*. Check for typos in names and ensure FCL uses the correct contract addresses.
8. **For "too few arguments" or "type mismatch" in function calls**: Check the function signature in the *deployed contract code*.

## Optional Binding
- **Use `if let` for optional binding.** Cadence does not support `guard let` syntax from Swift.
  ```cadence
  // Correct
  if let value = optionalValue {
      // use value
  } else {
      // handle nil
  }

  // Incorrect (Swift syntax)
  // guard let value = optionalValue else { return }
  ```

## Variable Initialization
- **All `var` declarations must be initialized.** Cadence requires variables to have an initial value upon declaration. This is different from some languages where uninitialized declarations are allowed.
  ```cadence
  // Correct
  var childColorR: UFix64 = 0.0

  // Incorrect
  // var childColorR: UFix64
  ```

## Switch Case Syntax
- **Separate cases for multiple values.** Cadence `switch` statements do not allow multiple values in a single `case` line (e.g., `case 0, 1:`).
  ```cadence
  // Correct
  switch value {
      case 0: // logic for 0
      case 1: // logic for 1 (can be same as 0 if desired)
      // ...
  }

  // Incorrect
  // switch value {
  //     case 0, 1: // logic for 0 or 1
  // }
  ```

## String Manipulation
- **`String.indexOf()` is not available.** Use `String.contains()` and `String.split(separator: String)` for searching and parsing strings.
  ```cadence
  let fullString = "Size:1.5|Form:2.0"
  if fullString.contains("Size:") {
      let components = fullString.split(separator: "|") // -> ["Size:1.5", "Form:2.0"]
      for component in components {
          let parts = component.split(separator: ":") // -> ["Size", "1.5"]
          if parts.length >= 2 && parts[0] == "Size" {
              if let sizeValue = UFix64.fromString(parts[1]) {
                  // use sizeValue
              }
          }
      }
  }
  ```

## Looping
- **Range-based loops (`0..<`) are not available.** Use `while` loops for iteration with an index.
  ```cadence
  var i = 0
  while i < array.length {
      // process array[i]
      i = i + 1
  }
  ```

## Access Control for Resource Fields
- **Fields intended for internal modification should be `access(self)` or `access(contract)`.**
- **Fields intended for external read access should be `access(all) view`.**
- **To modify fields from outside the resource (e.g., in a factory function within the same contract), they need to be `access(all)`.**
  - If a field is `access(self)`, functions within the same contract but outside the resource cannot directly modify it. Create a public function within the resource to set the value if modification is needed.
  ```cadence
  access(all) contract MyModule {
      access(all) resource MyTrait {
          access(all) var modifiableField: UFix64 // Can be set by MyModule functions
          access(self) var internalField: UFix64 // Only modifiable by MyTrait functions

          init() {
              self.modifiableField = 0.0
              self.internalField = 0.0
          }

          access(all) fun setInternalField(_ value: UFix64) {
              self.internalField = value
          }
      }

      access(all) fun createTraitWithModifiedField(): @MyTrait {
          let trait <- create MyTrait()
          trait.modifiableField = 10.0 // OK
          // trait.internalField = 5.0 // ERROR: internalField has self access
          trait.setInternalField(5.0) // OK: using public setter
          return <- trait
      }
  }
  ```

## View Function Purity
- **`view` functions cannot call non-`view` functions.** Ensure that any helper functions called by a `view` function are also marked as `view`.
- **Mathematical operations and string formatting are generally pure** and can be used in `view` functions if they don't modify state.
- **Calling contract-level (static) `view` functions from within a resource's `view` function is allowed.**
  ```cadence
  access(all) contract MyContract {
      access(all) resource MyResource {
          access(all) var data: UFix64

          init() { self.data = 10.0 }

          access(all) view fun getFormattedData(): String {
              // Calling a static view function from the contract level is OK
              return MyContract.formatData(self.data) 
          }
      }

      access(all) view fun formatData(_ val: UFix64): String {
          return val.toString().concat(" units")
      }
  }
  ```

## Type Conversion and Arithmetic
- **Explicit type conversion is required for arithmetic operations between different numeric types (e.g., `UInt64` and `UFix64`).**
  ```cadence
  let u64: UInt64 = 1000
  let ufix: UFix64 = 999.0
  let result = UFix64(u64) / ufix // Correct: UFix64 / UFix64
  
  // let badResult = u64 / ufix // Incorrect: Error, cannot divide UInt64 by UFix64
  ```
- **Underflow in UFix64:** Be careful with subtractions. `UFix64` cannot be negative. Ensure `a - b` is only performed if `a >= b`.
  ```cadence
  let a: UFix64 = 1.0
  let b: UFix64 = 2.0
  // let c = a - b // ERROR: underflow
  
  var c: UFix64 = 0.0
  if a >= b {
      c = a - b
  } else {
      c = b - a // Handle negative result appropriately
  }
  ```

## Rigorous Use of Pre/Post Conditions
- **Statement**: Implement `pre {}` and `post {}` blocks in all public contract functions and transactions to validate inputs, states, and ensure expected outputs. Use `panic()` with descriptive messages.
- **Example**:
  ```cadence
  access(all) contract ExampleContract {
      access(all) var value: Int

      init(initialValue: Int) {
          self.value = initialValue
      }

      access(all) fun updateValue(newValue: Int) {
          pre {
              newValue > 0 : "New value must be positive"
          }
          post {
              self.value == newValue : "Value update failed"
          }
          self.value = newValue
          log("Value updated to ".concat(newValue.toString()))
      }
  }
  ```
- **Why**: Clearly defines code invariants and expectations, enhancing robustness and simplifying debugging.

## Design for Idempotent Transactions
- **Statement**: Where feasible, design Cadence transactions to be idempotent. This means if a transaction is submitted multiple times (e.g., due to UI glitches or network retries), it should achieve the desired final state without causing unintended side effects, duplicate resource creation, or errors on subsequent executions. Check for existing states or resources before attempting to create or modify them.
- **Example (Conceptual Cadence within a transaction)**:
  ```cadence
  transaction(name: String, metadata: String) {
      prepare(signer: auth(Storage) &Account) {
          // Check if a resource already exists at the target path
          if signer.storage.borrow<&MyResource>(from: /storage/myResourcePath) == nil {
              let newResource <- create MyResource(name: name, metadata: metadata)
              signer.storage.save(<-newResource, to: /storage/myResourcePath)
              log("Resource created.")
          } else {
              log("Resource already exists. No action taken.")
              // Optionally, update the existing resource if that's the desired idempotent behavior
              // For example:
              // if let existing = signer.storage.borrow<&MyResource>(from: /storage/myResourcePath) {
              //     existing.updateMetadata(metadata)
              //     log("Resource metadata updated.")
              // }
          }
      }
  }
  ```
- **Why**: Enhances the reliability and robustness of your application, leading to a better user experience by gracefully handling accidental re-submissions or network uncertainties.




# Cadence Syntax Patterns & Best Practices

## Resource Type Syntax
- **Resource Declaration**: Use `@` symbol for resource types
  ```cadence
  var ownedNFTs: @{UInt64: {NonFungibleToken.NFT}}
  ```

- **Resource Parameters**: Use `@` for resource parameters
  ```cadence
  access(all) fun deposit(token: @{NonFungibleToken.NFT})
  ```

- **Resource References**: Use `&` for references
  ```cadence
  access(all) fun borrowNFT(_ id: UInt64): &{NonFungibleToken.NFT}?
  ```

## Interface Restrictions
Use curly braces `{}` for interface restrictions instead of direct interface types:
- **Correct**: `@{NonFungibleToken.NFT}` 
- **Incorrect**: `@NonFungibleToken.NFT`

## Reference Borrowing Patterns
- **Safe Borrowing**: 
  ```cadence
  let ref = &self.ownedNFTs[id]
  if ref != nil {
      return ref as! &MyNFT
  }
  ```

- **Avoid Complex Auth Casting**: Simplify authorization patterns
  ```cadence
  // Prefer simple casting over complex auth expressions
  let ref = &self.ownedNFTs[id] as! &MySpecificNFT
  ```

## Transaction Authorization Patterns
### Authorization Granularity
- **Principle of Least Privilege**: Grant only the necessary capabilities. Avoid overly broad authorizations if not required.
- **Storage Operations**: 
    - For full control: `signer: auth(Storage) &Account`
    - For granular control: `signer: auth(Mutate, Insert, Remove) &Account` (or a subset)
    - For specific standard operations (NFT, FT): Consider the five-capability model: `auth(BorrowValue, IssueStorageCapabilityController, SaveValue, UnpublishCapability, PublishCapability) &Account` when interacting with standard capabilities directly.
- **Read-Only Access**: If a transaction only reads public data or borrows public capabilities, it might not need any `auth` on the `signer` or might use `auth(Capabilities)` for linking public capabilities.

### Complete Authorization Template (Example for standard setup)
When setting up standard resources like an NFT Collection:
```cadence
transaction {
    prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, SaveValue, UnpublishCapability, PublishCapability) &Account) {
        // Example: Setup NFT Collection
        if signer.storage.borrow<&NonFungibleToken.Collection>(from: /storage/MyNFTCollection) == nil {
            let collection <- NonFungibleToken.createEmptyCollection()
            signer.storage.save(<-collection, to: /storage/MyNFTCollection)
            signer.capabilities.unpublish(/public/MyNFTCollection)
            signer.capabilities.publish(
                signer.capabilities.storage.issue<&NonFungibleToken.Collection>(/storage/MyNFTCollection),
                at: /public/MyNFTCollection
            )
        }
    }
}
```

### Authorization Error Prevention
- **Verify Signer Capabilities**: Ensure the signing account *actually possesses* the capabilities being authorized (e.g., has storage space, controllers for paths if `IssueStorageCapabilityController` is used for specific paths).
- **Match to Operation**: The most common error is a mismatch. If you `save`, you need `SaveValue` or broader `Storage`/`Mutate`. If you `publish`, you need `PublishCapability`.
- **Check `flow.json`**: Ensure the signer account in `flow.json` used for sending the transaction is the intended one with the correct keys.

## Contract Member Access Patterns
### Accessing Contract Constants and Functions
```cadence
// Correct - accessing public contract members (assuming they are defined as `access(all)` in the deployed contract)
let storagePath = MyContractName.CollectionStoragePath
let publicPath = MyContractName.CollectionPublicPath
let newNFT <- MyContractName.mintNFT(arg1, arg2)

// Error-prone - assuming members exist without verification
// ALWAYS verify the *deployed* contract has these as public members with the correct signature.
// Discrepancies between local .cdc file and deployed code are common sources of "unknown member" errors.
```

### Function Call Patterns
```cadence
// Verify function signatures from the *deployed* contract before calling.
// If createEmptyCollection() expects arguments on the deployed contract, provide them.
// let collection <- ContractName.createEmptyCollection(nftType: Type<@ContractName.NFT>()) // Example if it takes an argument

// For zero-argument functions (as defined in the deployed contract):
let collection <- ContractName.createEmptyCollection()
```

## Transaction Arguments and Hardcoding
- **Parameterize Transactions**: Prefer passing values as arguments to transactions rather than hardcoding them directly in the Cadence code, especially for values that might change or vary.
  ```cadence
  // Less flexible (hardcoded lifespanDays)
  transaction {
    // ...
    let lifespanDays = 10.0
    // ...
  }
  
  // More flexible (lifespanDays as an argument)
  transaction(lifespanDays: UFix64) {
    // ...
    // use lifespanDays argument
    // ...
  }
  ```
- **Configuration Constants**: For true constants related to contract logic that don't change per transaction, define them in the contract itself.

## Common Type Errors to Avoid
- **Dictionary Types**: Use `@{UInt64: {NonFungibleToken.NFT}}` not `@{UInt64: NonFungibleToken.NFT}`
- **Function Returns**: Use `@{NonFungibleToken.Collection}` not `@NonFungibleToken.Collection`
- **Type Casting**: Use interface restrictions in Type<> expressions: `Type<&MyContract.Collection>()`

## Access Modifiers & Entitlements
- **Withdraw Functions**: Use proper entitlements
  ```cadence
  access(NonFungibleToken.Withdraw) fun withdraw(withdrawID: UInt64): @{NonFungibleToken.NFT}
  ```

- **View Functions**: Mark read-only functions as `view`
  ```cadence
  access(all) view fun getIDs(): [UInt64]
  ```

## Contract Structure
- **Single Contract per File**: Each .cdc file should contain exactly one contract/interface
- **Nested Definitions**: Place supporting structs, resources, and interfaces inside the contract block
- **Import Organization**: Place all imports at the top of the file

## Error Prevention Patterns
- **Type Consistency**: Ensure consistent use of resource symbols and interface restrictions
- **Reference Safety**: Always check for nil before using optional references
- **Entitlement Usage**: Use appropriate entitlements for privileged functions
- **Interface Conformance**: Ensure all required interface methods are implemented
- **Authorization Completeness**: Include all necessary and *correctly scoped* capabilities in transaction `prepare()`.
- **Contract Member Verification**: Verify contract deployment and public member availability *on the target network*.

## Debugging Approach
When encountering Cadence compilation errors:
1. Check for missing `@` or `&` symbols in type declarations
2. Verify interface restrictions use `{}` syntax
3. Ensure single contract per file structure
4. Reference official Flow documentation and standard contracts
5. Compare against working examples from Flow's core contracts repository
6. **For authorization errors**: Ensure the `signer` has the correct `auth` capabilities for the operations performed in the transaction.
7. **For "unknown member" errors**: Verify the member exists and is `access(all)` in the *deployed contract code*. Check for typos in names and ensure FCL uses the correct contract addresses.
8. **For "too few arguments" or "type mismatch" in function calls**: Check the function signature in the *deployed contract code*.

## Optional Binding
- **Use `if let` for optional binding.** Cadence does not support `guard let` syntax from Swift.
  ```cadence
  // Correct
  if let value = optionalValue {
      // use value
  } else {
      // handle nil
  }

  // Incorrect (Swift syntax)
  // guard let value = optionalValue else { return }
  ```

## Variable Initialization
- **All `var` declarations must be initialized.** Cadence requires variables to have an initial value upon declaration. This is different from some languages where uninitialized declarations are allowed.
  ```cadence
  // Correct
  var childColorR: UFix64 = 0.0

  // Incorrect
  // var childColorR: UFix64
  ```

## Switch Case Syntax
- **Separate cases for multiple values.** Cadence `switch` statements do not allow multiple values in a single `case` line (e.g., `case 0, 1:`).
  ```cadence
  // Correct
  switch value {
      case 0: // logic for 0
      case 1: // logic for 1 (can be same as 0 if desired)
      // ...
  }

  // Incorrect
  // switch value {
  //     case 0, 1: // logic for 0 or 1
  // }
  ```

## String Manipulation
- **`String.indexOf()` is not available.** Use `String.contains()` and `String.split(separator: String)` for searching and parsing strings.
  ```cadence
  let fullString = "Size:1.5|Form:2.0"
  if fullString.contains("Size:") {
      let components = fullString.split(separator: "|") // -> ["Size:1.5", "Form:2.0"]
      for component in components {
          let parts = component.split(separator: ":") // -> ["Size", "1.5"]
          if parts.length >= 2 && parts[0] == "Size" {
              if let sizeValue = UFix64.fromString(parts[1]) {
                  // use sizeValue
              }
          }
      }
  }
  ```

## Looping
- **Range-based loops (`0..<`) are not available.** Use `while` loops for iteration with an index.
  ```cadence
  var i = 0
  while i < array.length {
      // process array[i]
      i = i + 1
  }
  ```

## Access Control for Resource Fields
- **Fields intended for internal modification should be `access(self)` or `access(contract)`.**
- **Fields intended for external read access should be `access(all) view`.**
- **To modify fields from outside the resource (e.g., in a factory function within the same contract), they need to be `access(all)`.**
  - If a field is `access(self)`, functions within the same contract but outside the resource cannot directly modify it. Create a public function within the resource to set the value if modification is needed.
  ```cadence
  access(all) contract MyModule {
      access(all) resource MyTrait {
          access(all) var modifiableField: UFix64 // Can be set by MyModule functions
          access(self) var internalField: UFix64 // Only modifiable by MyTrait functions

          init() {
              self.modifiableField = 0.0
              self.internalField = 0.0
          }

          access(all) fun setInternalField(_ value: UFix64) {
              self.internalField = value
          }
      }

      access(all) fun createTraitWithModifiedField(): @MyTrait {
          let trait <- create MyTrait()
          trait.modifiableField = 10.0 // OK
          // trait.internalField = 5.0 // ERROR: internalField has self access
          trait.setInternalField(5.0) // OK: using public setter
          return <- trait
      }
  }
  ```

## View Function Purity
- **`view` functions cannot call non-`view` functions.** Ensure that any helper functions called by a `view` function are also marked as `view`.
- **Mathematical operations and string formatting are generally pure** and can be used in `view` functions if they don't modify state.
- **Calling contract-level (static) `view` functions from within a resource's `view` function is allowed.**
  ```cadence
  access(all) contract MyContract {
      access(all) resource MyResource {
          access(all) var data: UFix64

          init() { self.data = 10.0 }

          access(all) view fun getFormattedData(): String {
              // Calling a static view function from the contract level is OK
              return MyContract.formatData(self.data) 
          }
      }

      access(all) view fun formatData(_ val: UFix64): String {
          return val.toString().concat(" units")
      }
  }
  ```

## Type Conversion and Arithmetic
- **Explicit type conversion is required for arithmetic operations between different numeric types (e.g., `UInt64` and `UFix64`).**
  ```cadence
  let u64: UInt64 = 1000
  let ufix: UFix64 = 999.0
  let result = UFix64(u64) / ufix // Correct: UFix64 / UFix64
  
  // let badResult = u64 / ufix // Incorrect: Error, cannot divide UInt64 by UFix64
  ```
- **Underflow in UFix64:** Be careful with subtractions. `UFix64` cannot be negative. Ensure `a - b` is only performed if `a >= b`.
  ```cadence
  let a: UFix64 = 1.0
  let b: UFix64 = 2.0
  // let c = a - b // ERROR: underflow
  
  var c: UFix64 = 0.0
  if a >= b {
      c = a - b
  } else {
      c = b - a // Handle negative result appropriately
  }
  ```

## Rigorous Use of Pre/Post Conditions
- **Statement**: Implement `pre {}` and `post {}` blocks in all public contract functions and transactions to validate inputs, states, and ensure expected outputs. Use `panic()` with descriptive messages.
- **Example**:
  ```cadence
  access(all) contract ExampleContract {
      access(all) var value: Int

      init(initialValue: Int) {
          self.value = initialValue
      }

      access(all) fun updateValue(newValue: Int) {
          pre {
              newValue > 0 : "New value must be positive"
          }
          post {
              self.value == newValue : "Value update failed"
          }
          self.value = newValue
          log("Value updated to ".concat(newValue.toString()))
      }
  }
  ```
- **Why**: Clearly defines code invariants and expectations, enhancing robustness and simplifying debugging.

## Design for Idempotent Transactions
- **Statement**: Where feasible, design Cadence transactions to be idempotent. This means if a transaction is submitted multiple times (e.g., due to UI glitches or network retries), it should achieve the desired final state without causing unintended side effects, duplicate resource creation, or errors on subsequent executions. Check for existing states or resources before attempting to create or modify them.
- **Example (Conceptual Cadence within a transaction)**:
  ```cadence
  transaction(name: String, metadata: String) {
      prepare(signer: auth(Storage) &Account) {
          // Check if a resource already exists at the target path
          if signer.storage.borrow<&MyResource>(from: /storage/myResourcePath) == nil {
              let newResource <- create MyResource(name: name, metadata: metadata)
              signer.storage.save(<-newResource, to: /storage/myResourcePath)
              log("Resource created.")
          } else {
              log("Resource already exists. No action taken.")
              // Optionally, update the existing resource if that's the desired idempotent behavior
              // For example:
              // if let existing = signer.storage.borrow<&MyResource>(from: /storage/myResourcePath) {
              //     existing.updateMetadata(metadata)
              //     log("Resource metadata updated.")
              // }
          }
      }
  }
  ```
- **Why**: Enhances the reliability and robustness of your application, leading to a better user experience by gracefully handling accidental re-submissions or network uncertainties.




